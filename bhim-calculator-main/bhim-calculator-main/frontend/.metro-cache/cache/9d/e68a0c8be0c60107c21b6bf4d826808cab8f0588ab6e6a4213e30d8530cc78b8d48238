{"dependencies":[{"name":"../../utils/is.js","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":1,"column":0,"index":0},"end":{"line":1,"column":51,"index":51}}],"key":"DL0lZsaza5vr7zl/bAzDYPBSOyA=","exportNames":["*"],"imports":1}},{"name":"../../utils/factory.js","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":2,"column":0,"index":52},"end":{"line":2,"column":49,"index":101}}],"key":"7GBwrsWWKVeatBp94Er80/CdjPI=","exportNames":["*"],"imports":1}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  Object.defineProperty(exports, \"createSymbolicEqual\", {\n    enumerable: true,\n    get: function () {\n      return createSymbolicEqual;\n    }\n  });\n  var _utilsIsJs = require(_dependencyMap[0], \"../../utils/is.js\");\n  var _utilsFactoryJs = require(_dependencyMap[1], \"../../utils/factory.js\");\n  var name = 'symbolicEqual';\n  var dependencies = ['parse', 'simplify', 'typed', 'OperatorNode'];\n  var createSymbolicEqual = /* #__PURE__ */(0, _utilsFactoryJs.factory)(name, dependencies, _ref => {\n    var {\n      parse,\n      simplify,\n      typed,\n      OperatorNode\n    } = _ref;\n    /**\n     * Attempts to determine if two expressions are symbolically equal, i.e.\n     * one is the result of valid algebraic manipulations on the other.\n     * Currently, this simply checks if the difference of the two expressions\n     * simplifies down to 0. So there are two important caveats:\n     * 1. whether two expressions are symbolically equal depends on the\n     *     manipulations allowed. Therefore, this function takes an optional\n     *     third argument, which are the options that control the behavior\n     *     as documented for the `simplify()` function.\n     * 2. it is in general intractable to find the minimal simplification of\n     *     an arbitrarily complicated expression. So while a `true` value\n     *     of `symbolicEqual` ensures that the two expressions can be manipulated\n     *     to match each other, a `false` value does not absolutely rule this out.\n     *\n     * Syntax:\n     *\n     *     math.symbolicEqual(expr1, expr2)\n     *     math.symbolicEqual(expr1, expr2, options)\n     *\n     * Examples:\n     *\n     *     math.symbolicEqual('x*y', 'y*x') // Returns true\n     *     math.symbolicEqual('x*y', 'y*x', {context: {multiply: {commutative: false}}}) // Returns false\n     *     math.symbolicEqual('x/y', '(y*x^(-1))^(-1)') // Returns true\n     *     math.symbolicEqual('abs(x)','x') // Returns false\n     *     math.symbolicEqual('abs(x)','x', simplify.positiveContext) // Returns true\n     *\n     * See also:\n     *\n     *     simplify, evaluate\n     *\n     * @param {Node|string} expr1  The first expression to compare\n     * @param {Node|string} expr2  The second expression to compare\n     * @param {Object} [options] Optional option object, passed to simplify\n     * @returns {boolean}\n     *     Returns true if a valid manipulation making the expressions equal\n     *     is found.\n     */\n    function _symbolicEqual(e1, e2) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var diff = new OperatorNode('-', 'subtract', [e1, e2]);\n      var simplified = simplify(diff, {}, options);\n      return (0, _utilsIsJs.isConstantNode)(simplified) && !simplified.value;\n    }\n    return typed(name, {\n      'Node, Node': _symbolicEqual,\n      'Node, Node, Object': _symbolicEqual\n    });\n  });\n});","lineCount":73,"map":[[7,2,5,0,"Object"],[7,8,5,0],[7,9,5,0,"defineProperty"],[7,23,5,0],[7,24,5,0,"exports"],[7,31,5,0],[8,4,5,0,"enumerable"],[8,14,5,0],[9,4,5,0,"get"],[9,7,5,0],[9,18,5,0,"get"],[9,19,5,0],[10,6,5,0],[10,13,5,0,"createSymbolicEqual"],[10,32,5,0],[11,4,5,0],[12,2,5,0],[13,2,1,0],[13,6,1,0,"_utilsIsJs"],[13,16,1,0],[13,19,1,0,"require"],[13,26,1,0],[13,27,1,0,"_dependencyMap"],[13,41,1,0],[14,2,2,0],[14,6,2,0,"_utilsFactoryJs"],[14,21,2,0],[14,24,2,0,"require"],[14,31,2,0],[14,32,2,0,"_dependencyMap"],[14,46,2,0],[15,2,3,0],[15,6,3,4,"name"],[15,10,3,8],[15,13,3,11],[15,28,3,26],[16,2,4,0],[16,6,4,4,"dependencies"],[16,18,4,16],[16,21,4,19],[16,22,4,20],[16,29,4,27],[16,31,4,29],[16,41,4,39],[16,43,4,41],[16,50,4,48],[16,52,4,50],[16,66,4,64],[16,67,4,65],[17,2,5,7],[17,6,5,11,"createSymbolicEqual"],[17,25,5,30],[17,28,5,33],[17,43,5,48],[17,47,5,48,"factory"],[17,62,5,55],[17,63,5,55,"factory"],[17,70,5,55],[17,72,5,56,"name"],[17,76,5,60],[17,78,5,62,"dependencies"],[17,90,5,74],[17,92,5,76,"_ref"],[17,96,5,80],[17,100,5,84],[18,4,6,2],[18,8,6,6],[19,6,7,4,"parse"],[19,11,7,9],[20,6,8,4,"simplify"],[20,14,8,12],[21,6,9,4,"typed"],[21,11,9,9],[22,6,10,4,"OperatorNode"],[23,4,11,2],[23,5,11,3],[23,8,11,6,"_ref"],[23,12,11,10],[24,4,12,2],[25,0,13,0],[26,0,14,0],[27,0,15,0],[28,0,16,0],[29,0,17,0],[30,0,18,0],[31,0,19,0],[32,0,20,0],[33,0,21,0],[34,0,22,0],[35,0,23,0],[36,0,24,0],[37,0,25,0],[38,0,26,0],[39,0,27,0],[40,0,28,0],[41,0,29,0],[42,0,30,0],[43,0,31,0],[44,0,32,0],[45,0,33,0],[46,0,34,0],[47,0,35,0],[48,0,36,0],[49,0,37,0],[50,0,38,0],[51,0,39,0],[52,0,40,0],[53,0,41,0],[54,0,42,0],[55,0,43,0],[56,0,44,0],[57,0,45,0],[58,0,46,0],[59,0,47,0],[60,0,48,0],[61,0,49,0],[62,4,50,2],[62,13,50,11,"_symbolicEqual"],[62,27,50,25,"_symbolicEqual"],[62,28,50,26,"e1"],[62,30,50,28],[62,32,50,30,"e2"],[62,34,50,32],[62,36,50,34],[63,6,51,4],[63,10,51,8,"options"],[63,17,51,15],[63,20,51,18,"arguments"],[63,29,51,27],[63,30,51,28,"length"],[63,36,51,34],[63,39,51,37],[63,40,51,38],[63,44,51,42,"arguments"],[63,53,51,51],[63,54,51,52],[63,55,51,53],[63,56,51,54],[63,61,51,59,"undefined"],[63,70,51,68],[63,73,51,71,"arguments"],[63,82,51,80],[63,83,51,81],[63,84,51,82],[63,85,51,83],[63,88,51,86],[63,89,51,87],[63,90,51,88],[64,6,52,4],[64,10,52,8,"diff"],[64,14,52,12],[64,17,52,15],[64,21,52,19,"OperatorNode"],[64,33,52,31],[64,34,52,32],[64,37,52,35],[64,39,52,37],[64,49,52,47],[64,51,52,49],[64,52,52,50,"e1"],[64,54,52,52],[64,56,52,54,"e2"],[64,58,52,56],[64,59,52,57],[64,60,52,58],[65,6,53,4],[65,10,53,8,"simplified"],[65,20,53,18],[65,23,53,21,"simplify"],[65,31,53,29],[65,32,53,30,"diff"],[65,36,53,34],[65,38,53,36],[65,39,53,37],[65,40,53,38],[65,42,53,40,"options"],[65,49,53,47],[65,50,53,48],[66,6,54,4],[66,13,54,11],[66,17,54,11,"isConstantNode"],[66,27,54,25],[66,28,54,25,"isConstantNode"],[66,42,54,25],[66,44,54,26,"simplified"],[66,54,54,36],[66,55,54,37],[66,59,54,41],[66,60,54,42,"simplified"],[66,70,54,52],[66,71,54,53,"value"],[66,76,54,58],[67,4,55,2],[68,4,56,2],[68,11,56,9,"typed"],[68,16,56,14],[68,17,56,15,"name"],[68,21,56,19],[68,23,56,21],[69,6,57,4],[69,18,57,16],[69,20,57,18,"_symbolicEqual"],[69,34,57,32],[70,6,58,4],[70,26,58,24],[70,28,58,26,"_symbolicEqual"],[71,4,59,2],[71,5,59,3],[71,6,59,4],[72,2,60,0],[72,3,60,1],[72,4,60,2],[73,0,60,3],[73,3]],"functionMap":{"names":["<global>","factory$argument_2","_symbolicEqual"],"mappings":"AAA;4ECI;EC6C;GDK;CDK"},"hasCjsExports":false},"type":"js/module"}]}