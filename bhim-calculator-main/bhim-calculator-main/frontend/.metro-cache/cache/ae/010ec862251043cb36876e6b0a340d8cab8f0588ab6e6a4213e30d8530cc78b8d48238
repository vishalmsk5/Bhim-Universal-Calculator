{"dependencies":[{"name":"../../utils/is.js","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":1,"column":0,"index":0},"end":{"line":1,"column":51,"index":51}}],"key":"DL0lZsaza5vr7zl/bAzDYPBSOyA=","exportNames":["*"],"imports":1}},{"name":"../../utils/factory.js","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":2,"column":0,"index":52},"end":{"line":2,"column":49,"index":101}}],"key":"7GBwrsWWKVeatBp94Er80/CdjPI=","exportNames":["*"],"imports":1}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  Object.defineProperty(exports, \"createSymbolicEqual\", {\n    enumerable: true,\n    get: function () {\n      return createSymbolicEqual;\n    }\n  });\n  var _utilsIsJs = require(_dependencyMap[0], \"../../utils/is.js\");\n  var _utilsFactoryJs = require(_dependencyMap[1], \"../../utils/factory.js\");\n  var name = 'symbolicEqual';\n  var dependencies = ['parse', 'simplify', 'typed', 'OperatorNode'];\n  var createSymbolicEqual = /* #__PURE__ */(0, _utilsFactoryJs.factory)(name, dependencies, _ref => {\n    var parse = _ref.parse,\n      simplify = _ref.simplify,\n      typed = _ref.typed,\n      OperatorNode = _ref.OperatorNode;\n    /**\n     * Attempts to determine if two expressions are symbolically equal, i.e.\n     * one is the result of valid algebraic manipulations on the other.\n     * Currently, this simply checks if the difference of the two expressions\n     * simplifies down to 0. So there are two important caveats:\n     * 1. whether two expressions are symbolically equal depends on the\n     *     manipulations allowed. Therefore, this function takes an optional\n     *     third argument, which are the options that control the behavior\n     *     as documented for the `simplify()` function.\n     * 2. it is in general intractable to find the minimal simplification of\n     *     an arbitrarily complicated expression. So while a `true` value\n     *     of `symbolicEqual` ensures that the two expressions can be manipulated\n     *     to match each other, a `false` value does not absolutely rule this out.\n     *\n     * Syntax:\n     *\n     *     math.symbolicEqual(expr1, expr2)\n     *     math.symbolicEqual(expr1, expr2, options)\n     *\n     * Examples:\n     *\n     *     math.symbolicEqual('x*y', 'y*x') // Returns true\n     *     math.symbolicEqual('x*y', 'y*x', {context: {multiply: {commutative: false}}}) // Returns false\n     *     math.symbolicEqual('x/y', '(y*x^(-1))^(-1)') // Returns true\n     *     math.symbolicEqual('abs(x)','x') // Returns false\n     *     math.symbolicEqual('abs(x)','x', simplify.positiveContext) // Returns true\n     *\n     * See also:\n     *\n     *     simplify, evaluate\n     *\n     * @param {Node|string} expr1  The first expression to compare\n     * @param {Node|string} expr2  The second expression to compare\n     * @param {Object} [options] Optional option object, passed to simplify\n     * @returns {boolean}\n     *     Returns true if a valid manipulation making the expressions equal\n     *     is found.\n     */\n    function _symbolicEqual(e1, e2) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var diff = new OperatorNode('-', 'subtract', [e1, e2]);\n      var simplified = simplify(diff, {}, options);\n      return (0, _utilsIsJs.isConstantNode)(simplified) && !simplified.value;\n    }\n    return typed(name, {\n      'Node, Node': _symbolicEqual,\n      'Node, Node, Object': _symbolicEqual\n    });\n  });\n});","lineCount":71,"map":[[7,2,5,0,"Object"],[7,8,5,0],[7,9,5,0,"defineProperty"],[7,23,5,0],[7,24,5,0,"exports"],[7,31,5,0],[8,4,5,0,"enumerable"],[8,14,5,0],[9,4,5,0,"get"],[9,7,5,0],[9,18,5,0,"get"],[9,19,5,0],[10,6,5,0],[10,13,5,0,"createSymbolicEqual"],[10,32,5,0],[11,4,5,0],[12,2,5,0],[13,2,1,0],[13,6,1,0,"_utilsIsJs"],[13,16,1,0],[13,19,1,0,"require"],[13,26,1,0],[13,27,1,0,"_dependencyMap"],[13,41,1,0],[14,2,2,0],[14,6,2,0,"_utilsFactoryJs"],[14,21,2,0],[14,24,2,0,"require"],[14,31,2,0],[14,32,2,0,"_dependencyMap"],[14,46,2,0],[15,2,3,0],[15,6,3,4,"name"],[15,10,3,8],[15,13,3,11],[15,28,3,26],[16,2,4,0],[16,6,4,4,"dependencies"],[16,18,4,16],[16,21,4,19],[16,22,4,20],[16,29,4,27],[16,31,4,29],[16,41,4,39],[16,43,4,41],[16,50,4,48],[16,52,4,50],[16,66,4,64],[16,67,4,65],[17,2,5,7],[17,6,5,11,"createSymbolicEqual"],[17,25,5,30],[17,28,5,33],[17,43,5,48],[17,47,5,48,"factory"],[17,62,5,55],[17,63,5,55,"factory"],[17,70,5,55],[17,72,5,56,"name"],[17,76,5,60],[17,78,5,62,"dependencies"],[17,90,5,74],[17,92,5,76,"_ref"],[17,96,5,80],[17,100,5,84],[18,4,6,2],[18,8,7,4,"parse"],[18,13,7,9],[18,16,11,6,"_ref"],[18,20,11,10],[18,21,7,4,"parse"],[18,26,7,9],[19,6,8,4,"simplify"],[19,14,8,12],[19,17,11,6,"_ref"],[19,21,11,10],[19,22,8,4,"simplify"],[19,30,8,12],[20,6,9,4,"typed"],[20,11,9,9],[20,14,11,6,"_ref"],[20,18,11,10],[20,19,9,4,"typed"],[20,24,9,9],[21,6,10,4,"OperatorNode"],[21,18,10,16],[21,21,11,6,"_ref"],[21,25,11,10],[21,26,10,4,"OperatorNode"],[21,38,10,16],[22,4,12,2],[23,0,13,0],[24,0,14,0],[25,0,15,0],[26,0,16,0],[27,0,17,0],[28,0,18,0],[29,0,19,0],[30,0,20,0],[31,0,21,0],[32,0,22,0],[33,0,23,0],[34,0,24,0],[35,0,25,0],[36,0,26,0],[37,0,27,0],[38,0,28,0],[39,0,29,0],[40,0,30,0],[41,0,31,0],[42,0,32,0],[43,0,33,0],[44,0,34,0],[45,0,35,0],[46,0,36,0],[47,0,37,0],[48,0,38,0],[49,0,39,0],[50,0,40,0],[51,0,41,0],[52,0,42,0],[53,0,43,0],[54,0,44,0],[55,0,45,0],[56,0,46,0],[57,0,47,0],[58,0,48,0],[59,0,49,0],[60,4,50,2],[60,13,50,11,"_symbolicEqual"],[60,27,50,25,"_symbolicEqual"],[60,28,50,26,"e1"],[60,30,50,28],[60,32,50,30,"e2"],[60,34,50,32],[60,36,50,34],[61,6,51,4],[61,10,51,8,"options"],[61,17,51,15],[61,20,51,18,"arguments"],[61,29,51,27],[61,30,51,28,"length"],[61,36,51,34],[61,39,51,37],[61,40,51,38],[61,44,51,42,"arguments"],[61,53,51,51],[61,54,51,52],[61,55,51,53],[61,56,51,54],[61,61,51,59,"undefined"],[61,70,51,68],[61,73,51,71,"arguments"],[61,82,51,80],[61,83,51,81],[61,84,51,82],[61,85,51,83],[61,88,51,86],[61,89,51,87],[61,90,51,88],[62,6,52,4],[62,10,52,8,"diff"],[62,14,52,12],[62,17,52,15],[62,21,52,19,"OperatorNode"],[62,33,52,31],[62,34,52,32],[62,37,52,35],[62,39,52,37],[62,49,52,47],[62,51,52,49],[62,52,52,50,"e1"],[62,54,52,52],[62,56,52,54,"e2"],[62,58,52,56],[62,59,52,57],[62,60,52,58],[63,6,53,4],[63,10,53,8,"simplified"],[63,20,53,18],[63,23,53,21,"simplify"],[63,31,53,29],[63,32,53,30,"diff"],[63,36,53,34],[63,38,53,36],[63,39,53,37],[63,40,53,38],[63,42,53,40,"options"],[63,49,53,47],[63,50,53,48],[64,6,54,4],[64,13,54,11],[64,17,54,11,"isConstantNode"],[64,27,54,25],[64,28,54,25,"isConstantNode"],[64,42,54,25],[64,44,54,26,"simplified"],[64,54,54,36],[64,55,54,37],[64,59,54,41],[64,60,54,42,"simplified"],[64,70,54,52],[64,71,54,53,"value"],[64,76,54,58],[65,4,55,2],[66,4,56,2],[66,11,56,9,"typed"],[66,16,56,14],[66,17,56,15,"name"],[66,21,56,19],[66,23,56,21],[67,6,57,4],[67,18,57,16],[67,20,57,18,"_symbolicEqual"],[67,34,57,32],[68,6,58,4],[68,26,58,24],[68,28,58,26,"_symbolicEqual"],[69,4,59,2],[69,5,59,3],[69,6,59,4],[70,2,60,0],[70,3,60,1],[70,4,60,2],[71,0,60,3],[71,3]],"functionMap":{"names":["<global>","factory$argument_2","_symbolicEqual"],"mappings":"AAA;4ECI;EC6C;GDK;CDK"},"hasCjsExports":false},"type":"js/module"}]}